# Lab_work_3
-----------------------------------------------------------------------------------------------------------------------------------------------------------
***ЗАДАНИЕ***

Реализовать класс Итератор чтения-записи для контейнера Set.
Для Итератора должны быть определены методы:
1) Переход к следующему узлу (постфиксный и префиксный инкремент) 
2) Проверка равенства двух итераторов (operator==)
3) Проверка неравенства двух итераторов (operator!=) 4) Получение значения текущего узла (operator*)
**Добавить в контейнер методы согласно вашему типу контейнера:
Множество**
1) iterator begin() – возвращает итератор и первый элемент контейнера
2) iterator end() – возвращает итератор на конец контейнера
3) Оптимизированная функция iterator insert(iterator pos, const T&amp; key) – вставляет элемент key в
позицию, на которую указывает итератор pos (если этот итератор указывает на “правильную”
позицию) и возвращает итератор на вставленный объект. Если объект уже был в множестве,
возвращает итератор на него. Конкретный параметр pos НЕ ЗАСТАВЛЯЕТ вставлять элемент
именно в это место.
4) iterator erase(iterator pos) – удаляет элемент, на который указывает итератор pos и возвращает
итератор следующий за удаленным объект
5) iterator erase(iterator begin, iterator end) – удаляет элементы от итератора begin до (не включая)
end, возвращает итератор
6) pair&lt;iterator,bool&gt; insert (const value_type&amp; val) - возвращает пару (итератор, булевское значение),
первый элемент которой указывает место вставленного или найденного значения, второй же
позволяет узнать, было значение вставлено (true) или уже находилось во множестве на момент
вставки (false)

**О реализации**

Данная программа реализует класс итератор для контейнера множество. Контейнер множество поддерживает такие методы итератора как begin() - возвращение итератора на первый элемент множества, end() - возвращение итератора на элемент следующий за последним элементом множества. Данная особенность возвращения не последнего элемента множества, а следующего за последним сделана для удобства перебора элементов контейнера в цикле. Данный цикл будет идти пока it != s.end(). Также реализован метод вставки элемента без параметра "рекомендуемое место вставки" и с таким параметром. Реализован метод удаления как элемента по указанной позиции в множестве, так и сразу нескольких элементов из диапазона [a, b], если концы a и b не выходят за пределы количества элементов в множестве.
Также у итераторов есть еще следующие методы (в данной программе не реализованы):
1) Функция distance(from, to), позволяет определить расстояние между элементами контейнера, с помощью пары итераторов from и to.
2) Функция advance(it, n), позволяет сдвинуть итератор it на целое число n, также для двунаправленных итераторов есть возможность делать сдвиг назад, используя отрицательное n.
3) Функция next(it), next(it, n), позволяет сдвинуть элемент на одну позицию вправо, либо же на n позиций вправо. Аналогичная реализация существует для движения назад на одну позицию, либо на n позиций.
4) Используя удаления нескольких элементов из диапазона a, b, можно реализовать полную очистку содержимого контейнера.
Все перечисленные методы могут быть применены к множеству.
Можно сказать, что вышеперечисленные функцит могут быть применены и к мультимножеству, отличие будет в функции вставки элемента в множество, не будет предварительно проверяться его наличие в множестве, так как в мультимножестве допустимы дубликаты. В мультимножестве также применима функция equal_range, она позволяет узнать диапазон, в котором находятся одинаковые значения.
При работе с итераторами для контейнера Set нельзя использовать арифметические операции и операции сравнения (в качестве альтернативы была создана функция advanced, о которой написано выше).
Данный итератор реализован отдельным классом, он не является другом для класса Set. Для реализации класса итератор были выполнены необходимые перегрузки. Управление обходом осуществляет клиент, так как по его команде осуществляется переход к следующему элементу, поэтому итератор является внешним, такой тип обладает большей гибкостью по сравнению с внутренним. Недостатком данной реализации является отсутствие функции advance(it, n), без нее неудобно ставить итератор на элемент в середине множества. Также из недостатков можно отметить не слишком эффективную по времени вставку и удаление элемента из контейнера.
